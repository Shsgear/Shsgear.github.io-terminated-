<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[es6]]></title>
    <url>%2F2018%2F08%2F03%2Fes6%2F</url>
    <content type="text"><![CDATA[Destructuring123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899let [x, y, ...z] = [1, 2, 3, 4, 5];console.log(x, y, z);let [l, m, ...n] = ['a'];// 结构不成功 输出undefined// 解构的右边必须是具有iterator接口的结构console.log(l, m, n);// a// undefined// []// 默认值生效的条件是，对象的属性值严格等于undefinedlet [b = true] = [];console.log(b); // truelet [c = 1, d = 3] = [2];console.log(c, d); // 2 3function f () &#123; console.log('YYY');&#125;let [a = f()] = [1]; //惰性求值// 等价于// let a;// if ([1][0] === undefined) &#123;// a = f();// &#125; else &#123;// x = [1][0]// &#125;let &#123; foo, bar &#125; = &#123; foo: "foo", baz: "baz" &#125;;console.log(foo, bar); // foo undefinedlet obj = &#123; first: "A", last: "B" &#125;;let &#123; first: fir, last: last &#125; = obj;console.log(fir, last);let objA = &#123; p: ['Hello', &#123; y: 'World' &#125;]&#125;let &#123; p: [o, &#123; y: k &#125;] &#125; = objA;console.log(o, k); //p是匹配模式，此处未赋值。 m: Hello n: World// 用途// 交换变量let nA = 1;let nB = 2;[nA, nB] = [nB, nA];console.log(nA, nB);// 从函数返回多个值function example() &#123; return &#123; eA: 1, eB: 2 &#125;;&#125;let &#123; eA, eB &#125; = example();console.log(eA, eB);// 函数参数定义function f1([x, y, z]) &#123; /* ... */&#125;f1([1, 2, 3]);function f2(&#123; x, y, z &#125;) &#123; /* ... */&#125;f2(&#123; z: 1, x: 2, y: 1 &#125;);// 提取接口返回值let jsonData = &#123; status: 'OK', id: 11, data: [122, 122]&#125;let &#123;status, id, data: number&#125; = jsonData;console.log(status, number);// 函数参数值的默认值function defaultParam(&#123; delay = 1000, str = 'Hello World!' &#125; = &#123;&#125;) &#123; setTimeout(() =&gt; &#123; console.log(str); &#125;, delay);&#125;defaultParam();defaultParam(&#123;str: 'Fxxk off'&#125;);// 加载模块的指定方法// import &#123; Button &#125; from 'element-ui'; Symbol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990const mySymbol = Symbol();console.log('mySymbol === Symbol()', mySymbol === Symbol());let a = &#123;&#125;;// method 1a = &#123; [mySymbol]: 'Hello mySymbol'&#125;// method 2a[mySymbol] = 'Hello anotherSymbol!'; // 为对象赋予Symbol属性// method 3Object.defineProperty(a, mySymbol, &#123; value: 'Hello thirdSymbol!' &#125;);a.mySymbol = 'Hello stringMySymbol'; // .操作符为对象赋予的是字符串属性console.log(a[mySymbol]) // Hello Symbolconsole.log(a['mySymbol']) // "Hello stringMySymbol"// 常规遍历对象不输出Symbol属性// 只输出字符串属性for (let i in a) &#123; console.log('props: ', i); &#125;// 只输出字符串属性console.log(Object.getOwnPropertyNames(a));// 此方法可以获取console.log(Object.getOwnPropertySymbols(a));// 或者此方法输出所有类型的键名console.log(Reflect.ownKeys(a));/* Symbol的用处 */// stage1 '魔法字符串' 耦合性太强。不变维护let getArea = (shape, option) =&gt; &#123; let area = 0; switch (shape) &#123; case 'Triangle': area = (option.width * option.height) * .5; break; /* ... */ default: break; &#125; return area;&#125;getArea('Triangle', &#123; width: 100, height: 100 &#125;);// stage2 将字符串变成变量。易于维护let areaShape = &#123; triangle: 'Triangle'&#125;getArea = (shape, option) =&gt; &#123; let area = 0; switch (shape) &#123; case areaShape.triangle: area = (option.width * option.height) * .5; break; /* ... */ default: break; &#125; return area;&#125;getArea(areaShape.triangle, &#123; width: 100, height: 100 &#125;);// stage3 变量并不需要指定一个值。只需要和其他变量区别开来，Symbol很适合areaShape = &#123; triangle: Symbol(), rectAngle: Symbol()&#125;getArea = (shape, option) =&gt; &#123; let area = 0; switch (shape) &#123; case areaShape.triangle: area = (option.width * option.height) * .5; break; /* ... */ default: break; &#125; return area;&#125;getArea(areaShape.triangle, &#123; width: 100, height: 100 &#125;); Set Map12345678910111213141516171819const s = new Set();[2, 3, 4, 5, 5, 2, 3, 6].forEach(x =&gt; s.add(x));// Set的add會將重复的值舍弃// 用法// 数组去重let a = [...new Set([1, 1, 2, 2, 3, 3, '3'])];console.log(a);// 实现并集let arrA = new Set([1, 2, 3]);let arrB = new Set([2, 3, 4]);let union = [...new Set([...arrA, ...arrB])];console.log('union', union);// 实现交集let intersect = new Set([...arrA].filter(x =&gt; arrB.has(x)));console.log('intersect', intersect);]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的变量对象与堆栈]]></title>
    <url>%2F2018%2F08%2F03%2Fstack%2F</url>
    <content type="text"><![CDATA[JavaScript中的变量对象与堆栈JavaScript中并没有严格意义上区分栈内存(FILO)与堆内存(FIFO)。 javascript执行上下文时会产生变量对象。一般变量对象存在堆内存中。为便于理解，将其与堆内存区别开来 1.变量对象与基本数据类型基本数据类型(undefined, Null, Number, String, Boolean)往往直接保存在变量对象中。基础数据类型都是按值访问，因此我们可以直接操作保存在变量中的实际的值。 123let a = 1;let b = a;b = 2; 2.引用数据类型与堆内存]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[evil setInterval与优化]]></title>
    <url>%2F2018%2F07%2F18%2Fevil-setInterval%E4%B8%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[邪恶的setInterval 不关心回调是否还在执行 有些时候我们执行完函数的时间要比间隔时间稍长。假如我们需要每5s从服务器发起请求，网络延迟、服务器不响应和其他可变因素可能阻止请求不能按时完成。 那么请求队列可能就并不是按照顺序来返回的 忽略执行函数时的错误 setInterval调用函数时若函数体内发生错误，不会停止而是继续运行错误的代码 不灵活 有时候我们可能需要可配置的执行次数。但是setInterval不提供 See the Pen 邪恶的setInterval by Shsgear (@Shsgear) on CodePen. 解决:优化后的interval，采用setTimeout See the Pen setInterval optimize by Shsgear (@Shsgear) on CodePen. 1234567891011121314151617// setInterval优化const interval = (func, wait, times) =&gt; &#123; let intervalInner = function (w, t)&#123; return function() &#123; if (typeof t === 'undefined' || t--&gt; 0) &#123; setTimeout(intervalInner, w); try &#123; func.apply(null); &#125; catch(err) &#123; throw err.toString(); &#125; &#125; &#125; &#125;(wait, times) setTimeout(intervalInner, wait);&#125; 此处是func无参数调用。假如func有参数，那么需要改进下函数 1234567891011121314151617181920const interval = (func, funcArgs, wait, times) =&gt; &#123; let intervalInner = function (w, t)&#123; return function() &#123; if (typeof t === 'undefined' || t--&gt; 0) &#123; setTimeout(intervalInner, w); try &#123; if (funcArgs !== undefined &amp;&amp; funcArgs.length &gt; 0) &#123; func.apply(null, [...funcArgs]); &#125; else &#123; func.apply(null); &#125; &#125; catch(err) &#123; t = 0; throw err.toString(); &#125; &#125; &#125; &#125;(wait, times) setTimeout(intervalInner, wait);&#125;]]></content>
      <categories>
        <category>javascript</category>
        <category>优化</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>setInterval优化</tag>
        <tag>setTimeout代替setInterval</tag>
        <tag>定时器</tag>
        <tag>闭包closure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
</search>
